# 第二章 变量和基本类型

### 基本算数类型

算术类型包括**整形**和浮点型；不同算法类型在不同机器上有差别，c++标准定义了最小尺寸。

| 类型 | 含义 | 最小尺寸|
|---|---|---|
| `bool` | 布尔类型  | 8bits |
| `char`| 字符 | 8bits |
| `wchar_t` | 宽字符 | 16bits |
| `char16_t` | Unicode字符 | 16bits |
| `char32_t` | Unicode字符 | 32bits |
| `short` | 短整型 | 16bits |
| `int` | 整型 | 16bits (在32位机器中是32bits) |
| `long` | 长整型 | 32bits |
| `long long` | 长整型 | 64bits （是在C++11中新定义的） |
| `float` | 单精度浮点数 | 6位有效数字 |
| `double` | 双精度浮点数 | 10位有效数字 |
| `long double` | 扩展精度浮点数 | 10位有效数字 |

### 带符号类型和不带符号类型

- 除去布尔型和扩展字符型，其他整型可以分为带符号和不带符号。
- 带符号可以表示负数、正数和0，不带符号只能表示大于等于0的数。

### 如何选择类型

- 当明确知晓数值不可能是负数时，选用无符号类型；
- 使用`int`执行整数运算。一般`long`的大小和`int`一样，而`short`常常显得太小。除非超过了`int`的范围，选择`long long`。
- 算术表达式中不要使用`char`或`bool`。
- 浮点运算选用`double`,`float`精度不够而且与`double`的计算代价相差不大。

### 类型转换

- 非布尔型赋给布尔型，初始值为0则结果为false，否则为true。
- 布尔型赋给非布尔型，初始值为false结果为0，初始值为true结果为1。
- 切勿混用带符号类型和不带符号类型，若混用，在带符号类型的数据为负数时会出现异常。

```c++
//错误例子，死循环，i永远不会小于0
for(unsigned_int i=10;i>=0;i--){
    std::cout<<i<<endl;
}
```

### 字面值常量

- 一个形如`42`的值被称作**字面值常量**（literal）。
  - 字符和字符串字面值。
    - 字符字面值：单引号， `'a'`
    - 字符串字面值：双引号， `"Hello World""`
  - 转义序列。`\n`、`\t`等。
  - 布尔字面值。`true`，`false`。
  - 指针字面值。`nullptr`

### 初始值

- 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。
- 内置类型的变量未被显示初始化时，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0，定义在函数体内部的将**不被初始化**，此时如果试图拷贝或其他形式访问此变量将引发错误。

### 变量声明和定义

- 变量的声明规定了变量的类型和名字，定义在此基础上还要申请存储空间，也可能会为变量赋一个初始值。
- 一个文件如果想使用别处定义的名字必须包含对那个名字的声明。
- 如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显示地初始化变量。
```c++
extern int i; //声明i而非定义i
int j;  //声明并定义j
extern double pi=4.1416;  //定义
```
- 在函数内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。
- **变量能且只能被定义一次，但可以被多次声明**。如果要在多个文件中使用一个变量，就必须将声明和定义分离，此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。

### 标识符
- C++的标志符(identifier)由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但对大小写字母敏感。
- 变量命名规范:
  - 标志符要能体现实际含义。
  - 变量名一般用小写字母，如index,不要使用Index或INDEX。
  - 用户自定义的类名一般以大写字母开头。
  - 如果标志符由多个单词组成，则单词间应有明显区分，如student_loan或studentLoan。

### 引用

- C++11中新增了“右值引用”。
- **引用**为对象起了另外一个名字,`引用即别名`。
```c++
int ival=1024;
int &refVal=ival; //引用
int &refVal;  //报错，引用必须被初始化

int i1=1024,i2=2048;
int &r=i1,r2=i2;  //r是一个引用,r2是int
int i3=1024,&r3=i3; //r3是一个引用

int &refVal4=10;  //错误：引用类型的初始值必须是一个对象
double dval=3.14;
int &refVal5=dval;  //错误：类型错误
```
### 指针

- 指针无需在定义时赋初值，和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。
- 因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。
- 通过取地址符`&`获取对象地址，通过解引用符`*`来访问指针指向的对象。
- 指针的值应属下列4种状态之一：
  - 指向一个对象。
  - 指向紧邻对象所占空间的下一个位置。
  - 空指针，意味着指针没有指向任何对象。
  - 无效指针，也就是上述情况之外的其他值。
- 空指针不指向任何对象。现在的C++程序最后使用nullptr初始化空指针。
```c++
\\生成空指针的方法
int *p=nullptr;
int *p=0;
int *p=NULL;  //NULL是一个预处理变量，其值就是0
```
- **建议初始化所有指针**。
- 引用一旦定义就无法令其再绑定到另外的对象，而指针可以指向新的对象。
```c++
int i=42;
int *p1=&i;
int *p2;  //p2如果定义块内，则其值是无法确定的
p2=p1;  //p2和p1指向同一个对象i
p2=0; //现在p2不指向任何对象了
```
- `void*`指针是一种特殊的指针类型，可用于存放任意对象的地址，无法访问void*指针所指的对象。

### 理解复合类型的变量

- 变量的定义包括一个基本数据类型和一组声明符(`*`，`&`等)，在一条定义语句中，可以定义出不同类型的变量。
```c++
int i=1024,*p=&i,&r=i;  //i是int型整数,p是int型指针,r是int型引用

int* p; //合法，但容易误导
int* p1,p2; //p1是指向int的指针,p2是int
int *p1,*p2;  //p1和p2都是指向int的指针
```

### const变量

- 使用关键字`const`对不可变变量进行限定，const对象一旦创建后其值就不能再改变，所以const对象必须初始化。
- `const`关键字的主要限制就是只能在const类型的对象上执行不改变其内容的操作。
- 为了让多个文件共享一个const变量，解决的办法是，对于const变量不管是声明还是定义都添加`extern`关键字，这样只需定义一次就可以了。
```c++
//file_c.cc定义并初始化了一个变量，该变量能被其他文件访问
extern const int bufSize=fcn();
//file_1.h 头文件
extern const int bufSize; //与file_1.cc中定义的bufSize是同一个
```
- 如果想在多个文件之间共享const对象，必须在变量的定义之前添加`extern `关键字。
- 可以把引用绑定在const对象上，这些引用被称为**对常量的引用**。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。
```c++
const int ci=1024;
const int &r1=ci; //正确：引用及其对应的对象都是常量
r1=42;  //错误：r1是对常量的引用
int &r2=ci; //错误：试图让一个非常量引用指向一个常量对象
```
- C++运行为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式。
```c++
int i=52;
const int &r1=i;  //允许将const int&绑定到一个普通int对象上
const int &r2=42; //正确：r1是一个常量引用
const int &r3=r1*2; //正确：r3是一个常量引用
int &r4=r1*2; //错误：r4是一个普通的非常量引用
```
- 可以令指针指向常量或非常量，这些指针被称为**指向常量的指针**，指向常量的指针**不能用于改变其所指对象的值**。要想存放常量对象的地址,**只能使用指向常量的指针**。
- 指向常量的指针没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变所指对象的值，而没有规定那个对象的值不能通过其他途径改变。
```c++
const double pi=3.14;
double *ptr=&pi;  //错误:ptr是一个普通指针
const double * cptr=&pi;  //正确:cptr可以指向一个双精度常量
*cptr=42; //错误:不能给*cptr赋值

double dval=3.14;
cptr=&dval; //正确:但是不能通过cptr改变dval的值
```

### const指针

- **常量指针**把`*`放在`const`关键字之前用以说明指针是一个常量，代表着不变的是指针本身的值而非指向的那个值。
```c++
int errNumb=0;
int *const curErr=&errNumb; //curErr将一直指向errNumb
const double pi=3.1459;
const double *const pip=&pi;  //pip是一个指向常量对象的常量指针
```

### 顶层const和底层const

- 指针本身是一个对象，它又可以指向另外一个对象。因此，指针本省是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。
- 用名词**顶层const**表示指针本省是个常量，而用名词**底层const**表示指针所指的对象是一个常量。
```c++
int i=0;
int *const p1=&i; //不能改变p1的值，这是一个顶层const
const int c1=42;  //不能改变c1的值，这是一个顶层const
const int *p2=&c1;  //运行改变p2的值，这是一个底层const
const int *const p3=p2;  //靠右的const是顶层const,靠左的是底层const
const int &r=c1;  //用于声明引用的const都是底层const
```
- 当执行对象的拷贝时，常量是顶层const还是底层const的区别明显。其中，顶层const不受什么影响；对于底层const，拷入和拷出的对象必须具有相同底层const资格，或者两个对象的数据类型必须能够转换（一般来说，非常量可以转换为常量，反之则不行）。
```c++
i=c1; //正确
p2=p3;  //正确，指向类型相同且都是顶层const

int *p=p3;  //错误，p3包含底层const的定义，而p没有
p2=&i;  //正确:int*能转为const int*
int &r=c1;  //错误：普通的int&不能绑定在int常量上
const int &r2=i;  //正确:int可以转换为const int&
```

### constexpr和常量表达式

- **常量表达式(cosnt expression)**是指值不会改变并且在**编译过程**就能得到计算结果的表达式。
- 字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。
```c++
const int max_files=20; //是常量表达式
const int limit=max_files+1;  //是常量表达式
int staff_size=27;  //不是常量表达式
const int sz=get_size() //sz不是常量表达式，因为具体值要到运行时才能获取到。
```
- C++11新标准规定，运行将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。
```c++
constexpr int mf=20;  //20是常量表达式
constexpr int limit=mf+1; //mf+1是常量表达式
constexpr int sz=size();  //只有当size()是一个constexpr函数时才是一条正确的声明语句
```
- 注意：在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。
```c++
const int *p=nullptr; //p是一个指向整型常量的指针
constexpr int *q=nullptr; //q是一个指向整数的常量指针
```

### 类型别名
- **类别别名**是一个名字，它是某种类型的同义词。
- 有两种方法可用于定义类别别名：
  - 传统的方法是使用关键字`typedef`
  - C++11新标准规定了一种新的方法，使用别名声明来定义类型的别名
```c++
typedef double wages; //wages是double的同义词
typedef wages base,*p;  //base是double的同义词,p是double*的同义词

using SI=Sales_item;  //SI是Sales_item的同义词
```
- 如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里会产生意想不到的后果
```c++
typedef char *pstring;
const pstring cstr=0; //cstr是指向char的常量指针
const pstring *ps;  //ps是一个指针，它的对象是指向char的常量指针
/*总结：这里的const修饰的别名里的指针,不能简单地把别名换成本来的样子*/
```

### auto类型说明符
- C++11新标准引入了`auto`类型说明符，用它就能让编译器替我们去分析表达式所属的类型。
- 使用auto可以在一条语句中声明多个变量，但一条声明语句中只能有一个基本类型。
```c++
auto itme=val1+val2;  //itme初始化为val1和val2相加的结果

auto i=0,*p=&i; //正确：i是整数，p是整型指针
auto sz=0,pi=3.14;  //错误：sz和pi的类型不一致
```

### decltype类型指示符
- C++11新标准引入了第二种类型说明符`decltype`，它的作用是选择并**返回操作数的数据类型**。
```c++
decltype(f()) sum=x;  //sum的类型就是函数f的返回类型

const int ci=0,&cj=ci;
decltype(ci) x=0; //x的类型是const int
decltype(cj) y=x; //y的类型是const int&,y绑定到变量x
decltype(cj) z; //错误：z是一个引用，必须初始化
```
- 切记:`delctype((variable))`(注意是双层括号)的结果永远是引用，而`decltype(variable)`结果只有但variable本身就是一个引用时才是引用。
```c++
int i=42;
decltype((i)) d; //错误：d是int&，必须初始化
decltype(i) e; //正确：e是一个（未初始化）int
```

### 自定义数据结构






