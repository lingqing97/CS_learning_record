### 二分法总结

#### 关键点

1. 区间与中间数划分的关系(主要是为了防止两个元素的时候陷入死循环):

* 划分 [left, mid] 与 [mid + 1, right] ，mid 被分到左边，对应 int mid = left + (right - left) / 2;；
* 划分 [left, mid - 1] 与 [mid, right] ，mid 被分到右边，对应 int mid = left + (right - left + 1) / 2;。

2. 退出循环的时候有 left == right 成立，此时如果能确定问题一定有解，返回 left 即可，如果不能确定，需要单独判断一次

3. 二分法的核心思想在于**每一轮过滤哪部分区间**

**无需记模板**


### 典型题

#### 题型一：在数组中查找符合条件的元素的下标

#### 1095. 山脉数组中查找目标值

##### 题目描述
![avatar](../image/../../image/leetcode_1095.jpg)

##### 参考题解

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left=0,right=nums.size()-1;
        while(left<right){
            int mid=left+(right-left)/2;
            if(nums[left]<=nums[mid]){
               //左边有序 
               if(nums[left]<=target&&target<=nums[mid]){
                   right=mid;
               }
               else{
                   left=mid+1;
               }
            }
            else{
                //右边有序
                //注意这里不要写成if(nums[mid]<=target&&target<=nums[right])
                //因为若有等于则令left=mid+1可能会将nums[mid]==target这种情况过滤
                if(nums[mid]<target&&target<=nums[right]){
                    left=mid+1;
                }
                else{
                    right=mid;
                }
            }
        }
        return nums[left]==target?left:-1;
    }
};
```

**Hits:过滤区间的条件一定考虑清楚，这里主要是等号取不取的情况**


#### 81. 搜索旋转排序数组 II

##### 题目描述

![avatar](../image/../../image/leetcode_81.jpg)

##### 参考题解

```cpp
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        int left=0,right=nums.size()-1;
        while(left<right){
            int mid=left+(right-left)/2;
            if(nums[left]<nums[mid]){
                //左边一定有序
                if(nums[left]<=target&&target<=nums[mid]){
                    right=mid;
                }
                else{
                    left=mid+1;
                }
            }
            else if(nums[left]>nums[mid]){
                //右边有序
                if(nums[mid]<target&&target<=nums[right]){
                    left=mid+1;
                }
                else{
                    right=mid;
                }
            }
            else{
                //nums[left]==nums[mid]
                //这时无法判断左边是否一定有序比如(23222)
                if(nums[left]==target) return true;
                ++left;
            }
        }
        return nums[left]==target;
    }
};
```

**Hits:与上一题不同，这里不要要考虑出现重复元素的情况**


##### 剑指 Offer 11. 旋转数组的最小数字

##### 题目描述

![avatar](../image/../../image/leetcode_剑指Offer11.jpg)

##### 参考题解

```cpp
class Solution {
public:
    int minArray(vector<int>& numbers) {
        int left=0,right=numbers.size()-1;
        //找左右区间的交界
        while(left<right){
            int mid=left+(right-left)/2;
            //关键在于过滤值较大的区间，所以这里numbers[mid]要和numbers[right]比较，而不是和numbers[left]比较
            if(numbers[mid]<numbers[right]){
                right=mid;
            }
            else if(numbers[mid]>numbers[right]){
                left=mid+1;
            }
            else{
                --right;
            }
        }
        return numbers[left];
    }
};
```

**Hits:套路题，暂时没有好的理解**