### 虚函数

当一个类本身定义了虚函数，或其父类有虚函数时，为了支持多态机制，编译器将为该类添加一个虚函数表指针(`vptr`)。

虚函数表指针一般放在对象内存布局的第一个位置上，这是为了保证多层继承或多重继承的情况下能以最高效率取得虚函数表。

在C++中，有两种数据成员(`class data members`):`static`和`nonstatic`,以及三种类成员函数(`class member functions`):`static`,`nonstatic`和`virtual`.

在非继承的C++对象模型中，`nonstatic`数据成员被置于每一个类对象中，而`static`数据成员被置于类对象之外。`static`和`nonstatic`函数也都放在类对象之外，而对于`virtual`函数，则通过虚函数表+虚指针来支持。

每个类有一个虚表，虚表中存放着一堆函数指针，这些指针指向该类每一个虚函数。

每个类对象都有一个虚表指针(`vptr`)，由编译器为其生成,vptr的位置由编译器决定，许多编译器将vptr放在一个类对象的最前端。

另外，虚函数表的前面设置了一个指向`type_info`的指针，用于支持`RTTI`(Run Time Type Identification,运行时类型识别).

### 单继承

在C++对象模型中，对于一般继承（这个一般是相对于虚拟继承而言），若子类重写（overwrite）了父类的虚函数，则子类虚函数将覆盖虚表中对应的父类虚函数(注意子类与父类拥有各自的一个虚函数表)(如父类的析构函数定义为虚函数，则子类的析构函数会覆盖父类的析构函数)；若子类并无overwrite父类虚函数，而是声明了自己新的虚函数，则该虚函数地址将扩充到虚函数表最后（在vs中无法通过监视看到扩充的结果，不过我们通过取地址的方法可以做到，子类新的虚函数确实在父类子物体的虚函数表末端）。而对于虚继承，若子类overwrite父类虚函数，同样地将覆盖父类子物体中的虚函数表对应位置，而若子类声明了自己新的虚函数，则编译器将为子类增加一个新的虚表指针vptr

### 多继承

单继承中（一般继承），子类会扩展父类的虚函数表。在多继承中，子类含有多个父类的子对象，该往哪个父类的虚函数表扩展呢？当子类overwrite了父类的函数，需要覆盖多个父类的虚函数表吗？

* 子类的虚函数被放在声明的第一个基类的虚函数表中。
* overwrite时，所有基类的print()函数都被子类的print()函数覆盖。
* 内存布局中，父类按照其声明顺序排列。
其中第二点保证了父类指针指向子类对象时，总是能够调用到真正的函数。