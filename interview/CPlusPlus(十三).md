## Day-13

### 问题

> 介绍一下STL的allocator

### 参考答案

参考:[《STL源码剖析》chapter2 空间配置器](https://blog.csdn.net/qq_39621037/article/details/113619204)

`STL allocator`封装了STL容器在内存管理上的底层细节。我们日常所习惯的内存分配是使用`new`运算符，内存释放是使用`delete`运算符。

而`new`运算符实际包含两个步骤：

1. 调用全局`::operator new`分配内存（实际上就是调用`malloc`分配内存）
2. 调用对象相应的构造函数来构造对象

同理，`delete`运算符也包含两个步骤:

1. 调用对象相应的析构函数来析构对象
2. 调用全局`::operator delete`释放内存（实际上是调用`free`释放内存）

在`STL`中，通过`STL allocator`将对象构造/析构和内存分配/释放两个步骤分开来。其中，对象的构造和析构是分别通过`allocator::construct()`(使用`placement new`来调用对象的构造函数)和`allocator::destory()`(使用对象的析构函数)来实现。内存分配/释放是分别通过`allocator::allocate()`(通过`malloc`分配内存)和`allocator::deallocate()`(通过`free`释放内存)来实现。

此外，由于`allocator`调用`malloc`来分配内存，在给小型区块分配内存时可能会产生`内存碎片`问题。为了解决这个问题，提高内存利用率，`STL`中的`allocator`采用了`双层级配置器`。

当配置区块超过`128 bytes`便使用第一级配置器，第一级配置器中内存的申请和释放直接采用`malloc`和`free`;当配置区块小于`128 bytes`时便采用第二级配置器，第二级配置器中内存的申请和释放通过`内存池`来管理。

第二级配置器中的内存池实现细节：维护一个16个自由链表(`free-lists`),各自管理大小为8,16,24,32,40,48,56,64,72,80,88,...128 bytes的小额区块，每次配置或释放一块内存时，需要维护对应的自由链表。

> 进阶：请你实现一个简单的内存池?