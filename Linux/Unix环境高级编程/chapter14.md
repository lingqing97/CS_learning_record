[toc]

### chapter14 高级I/O

#### 非阻塞I/O

非阻塞I/O使我们可以发出`open`、`read`和`write`这样的I/O操作，并使这些操作不会永远阻塞。如果这种操作不能完成，则调用立刻出错返回，表示该操作如继续执行将阻塞。

对于一个给定的描述符，有两种为其指定非阻塞I/O的方法:

1. 如果调用`open`获得描述符，则可指定`O_NONBLOCK`标志
2. 对于已经打开的一个描述符，则可调用`fcntl`,由该函数打开`O_NONBLOCK`文件状态标志

#### 记录锁

`记录锁(record locking)`的功能是：当第一个进程正在读或修改文件的某个部分时，使用记录锁可以阻止其他进程修改同一文件区。（一个更适合的术语可能是`字节范围锁`,因为它锁定的只是文件中的一个区域）

通过`fcntl`可以对记录锁进行相应的设置:

```cpp
#include<fcntl.h>
int fcntl(int fd,int cmd,.../* struct flock *flockptr */)
```

`fcntl`可以设置的3中cmd为`F_GETLK`(判断锁是否会被阻塞),`F_SETLK`(设置记录锁),`F_STELKW`(`F_SETLK`的阻塞版本)

`fcntl`可以设置两种类型的锁:`共享读锁`和`独占性写锁`。基本规则是：任意多个进程在一个给定的字节上可以有一把共享的读锁，但是在一个给定字节上只能有一个进程有一把独占写锁。

上面的基本规则并不适用于单个进程提出的多个锁请求：如果一个进程对一个文件区间已经有了一把锁，后来该进程又企图在同一文件区间再加一把锁，那么新锁将替换已有锁。比如，若一进程在某文件的16~32字节区间有一把写锁，然后又试图在16~32字节区间加一把读锁，那么该请求将成功执行，原来的写锁会被替换为读锁。

死锁：如果两个进程相互等待对方持有并且不释放（锁定）的资源时，则这两个进程就处于死锁状态。当`fcntl`检测到死锁时，内核必须选择一个进程接收出错返回。

关于记录锁的自动继承和释放有3条规则:

1. 锁与进程和文件两者相关联：当一个进程终止时，它所建立的锁全部释放；无论一个描述符何时关闭，该进程通过这一描述符引用可以将其锁释放。

```cpp
//例子一：锁与文件相关联
fd1=open(pathname,...);
read_lock(fd1,...);
fd2=dup(fd1);
close(fd2);     //在close(fd2)后，在fd1上设置的锁会被释放

//例子二：锁与文件相关联
fd1=open(pathname,...);
read_lock(fd1,...);
fd2=open(pathname,...);
close(fd2);     //在close(fd2)后，在fd1上设置的锁会被释放

//解释：后面会介绍，lockf指针是在v节点表项中，同一文件描述符对同一v节点表项操作，所以无论是dup和open，调用close之后都会将fd1上设置的锁释放
```

2. 由`fork`产生的子进程不继承父进程所设置的锁。如果子进程通过`fork`继承父进程的锁，则父进程和子进程就可以同时写同一个文件，则显然是不合理的。

3. 在执行`exec`后，新程序可以继承原执行程序的锁。但是注意，如果对一个文件描述符设置了执行时关闭标志，将释放相应文件的所有锁？

锁机制可以分为`建议性锁机制`和`强制性锁机制`:

1. `建议性锁机制`:每个使用文件的进程都要主动检查文件是否有锁存在（这只是建议，是否执行取决于进程本身，有的进程忽略该类锁强制读写文件）

2. `强制性锁机制`:强制性锁会让内核检查每一个`open`、`read`和`write`,验证调用进程是否违背了正在访问的文件上的某一把锁。（强制性锁有时也被称为强迫方式锁）

`FreeBSD`中记录锁机制的实现细节如下:

![avatar](images/../../../image/unix_记录锁.jpg)

在父进程中，关闭fd1,fd2或fd3中的任意一个都将释放父进程设置的写锁。在关闭这3个描述符中的任意一个时，内核会从该描述符所关联的i节点开始，逐个检查`lockf`链接表中的各项，并释放由调用进程持有的各把锁。**内核并不清楚(也不关心)父进程是用这3个描述中的哪一个来设置这把锁的。**


#### I/O多路转接

